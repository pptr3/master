

#######################
A* --> h + real cost of the arch
Best Search --> h

Ammissibilià: è ammissibile se la h di ogni nodo è minore o uguale al reale costo per raggiungere il goal


#######################






























####################### STRIPS ######################

- First thing to do is do a pop from the goal stack. We extract a conjunction.
Since it is a conjunction we have to decide an order.
Let’s choose first on(c, b) and then on(a, c).
We have to state again the conjunction because every time I plan for one I have to check whether the conjunction holds.

-  now we have to check whether on(c, b) is already true in the initial state. In this case is not true (it does not present in the current state). So we have to plan for it.

- now, since we have to plan for it, we have to find an action where this condition (on(c, b)) is in its ADD LIST. Which one is? STACK(c, b), because stack has in its add list on(X, Y).

- update the goal as follows: remove on(c, b) from the goal stack, and push the action found before which is STACK(c, b) and also push all the preconditions of the stack action (which are clear(b) and holding(c)).

-  now we do another iteration of the algorithm. So, is the goal stack empty? If yes, finish, otherwise continue. In this case no.
Note that the current state does not change. We have another goal state but the current state in always the same.

- now from the top of the goal stack we have clear(b) and holding(c). Are both true? No, only clear(b) is true (note that the current state still do not change even if this is true). So extract all the conjunction and since it is a conjunction we have to decide an order. We decide the order clear(b) and then holding(c).

- now we extract clear(b). Is clear(b) true in the current state? Yes! So, I remove it from the goal state (NOT FROM THE CURRENT STATE).

- now we extract holding(c). Is it true is the initial state? No. So we have to find an action that has holding(c) is its add list. We have two actions in this case, unstack and pickup. In this case we have to use our knowledge to choose which one is better looking at the current state. We use unstack. So we can remove holding(c) from the goal stack and push unstack. We leave the Y as a variable because we do not know from where we are unstacking. We push also the preconditions of unstack. 

- we notice now that handempty and clear(c) and on(c, Y) is true in the current state IF we apply the substitution Y / a. So we can remove all these three conjunctions and apply the substitution Y / a to the rest of the stack.

- now we are in a situation where we are popping an action, unstack(c, a). When this happens, WE CHANGE THE STATE. So we remove unstack(c, a) from the goal stack and APPLY this action on the current state. Applying the action means that we delete from the current state what is present in the DELETE LIST of unstack and add in the current state what is present if its ADD LIST.

- now we pop clear(b), but we can see that it is true in the current state, so re remove it.

- now we pop clear(b) and holding(c), it is true in the current state so we remove it

- now we pop stack(c, b), since it is an action we apply the action to the current state, deleting what is present in its delete list and add in the current state what is in its add list.

- continue..

- when the goal stack is empty, we have finished

FINAL PLAN: is the set of ACTIONS starting from the end till the goal. I start from the last empty block of the goal stack and take the actions in order going back to the beginning. I take just the *new actions*, it will be a set.

##################################################





































#################### GRAPH PLAN #######################

GRAPH CONSTRUCTION

LEVEL 0
We construct this by put the initial state propositions ( at(locationA), have_battery, ...).


LEVEL 1
Now, we can do (draw a point in the level 1) an action iff the preconditions of this actions are respected, namely are present in the level 0. 
If so, we connect the propositions (preconditions) of this action from level 0 to the action in level 1 through ADD ARCHS arrows.

The last action left to add in the level 1 is the NO-OP action. We have a single NO-OP for each propositions in the level 0. We can draw just one for simplicity. 


LEVEL 2
Now we have to build the proposition level (which is the level 2). The first thing we have to do is to move all the propositions of the level 0 (which are bind to the NO-OP of level 1) to level 2 and then we connect these propositions through ADD ARCHS form the NO-OP of the level 1.

Now we need to add all the effects of the action of level 1. 
So basically, for each action, we delete through DELETE ARCHS arrows the propositions that are present in its delete list and add through ADD ARCHS arrows what is present in its add list.



INCONSISTENT ACTIONS

First type of inconsistency
- when an action has in its add list a proposition and another action has in its delete list the same proposition. So one is adding and the other is removing the same proposition. 
So we need to look whether in the level 2 there is a proposition that have and incoming add arch arrow and an incoming delete arch. 
If yes, we write for example that "the load(a, l) is incompatible with the NO-OP(at(a, l)). [at(a, l) is the proposition that has an incoming add arch and delete arch in the 2 level]. 

Second type of inconsistency
- the second one is interference. How to figure it out? We look from level 1 to 2 and we have to check whether an action deletes the preconditions of another action. And for example we write "MOVE(r,l,p) is inconsistent inconsistent with LOAD(a, l)"



INCONSISTENT PROPOSITIONS

First type of inconsistency
Basically, for each action of the 1 level that adds some new propositions in the 2 level, we need to check whether it deletes something to add that action. If the propositon it deletes is a precondition of the same action that is adding the new proposition, then the two propositions are inconsistent.
So for example we can see that in order to add in(r, a), we delete at(a, l). But to add in(r, a) we must to have at(a, l) as a precondition of LOAD(a, l). Thus they are inconsistent.

Second type of inconsistency
Here we are going to concentrate on the new things added in the level 2, more precisely on their interactions.
Let's consider the interactions between in(r, b) -> at(r, p). We can notice that in order to add at(r, p), we need to execute MOVE(r, l, p) that deletes at(r, l). But to add in(r, a), we need to execute LOAD(a, l) which requires at(r, l) (which MOVE deletes). Thus in(r, b) -> at(r, p) is an inconsistent proposition.
    
##################################################




















#################### CSP ###########################

FC: if I am asked to only show the domain reduction, I just need ti di 1 step!
    if I am asked to find a SOL, after the first step I assign a value to the next variable and continue with FC.
    
Examples:
[1..3] > [1..3]
FLA becomes: [2..3] > [1..2]
PLA becomes: [2..3] > [1..3]

- When finding a SOL, like 1 < [1..4], it does no matter whether it is FLA, PLA o FC, this will always become 1 < [2..4]

- [2..4] = 2 becomes [2] = 2
- 2 =\= [1..4] becomes 2 =\= [1, 3, 4]
    
    
    
ARCH CONSISTENCY
An arch is consistent iff for each value of each domain, there is at least a value in every other domain that matches the existing constraint between the two nodes.

   B --- < ---> C      (B < C)
[1..4]      [2,4,6]

This is ok, I do not have to delete anything!
1(B) < 2(C)
2(B) < 4(C)
3(B) < 4(C)
4(B) < 6(C)

In B we have at least one support for all its values in C, viceversa.


##################################################
















##################### KOWALSKI ###################

initial state: [at(locationA), have_battery, handempty]
goal: [picture(locationA), picture(locationB)] 


take_picture(Location)
PRECOND: have_battery, at(Location), have_camera
DELETE: have_battery
ADD: picture(Location)

1)Model the action TAKE PICTURE (preconditons, effects and frame axioms), using the Kowalsky formulation.

SOL:


INITIAL STATE: # holds of all propositions of initial state
holds(at(locationA),s0).
holds(have_battery, s0).
holds(handempty,s0).


GOAL: # poss and holds of all propositions of the goal
:- poss(S, holds(picture(locationA), S), holds(picture(locationB), S)).

EFFECTS: # holds of the proposition of ADD LIST when we do() the action take_picture in a state S
holds(picture(Location), do(take_picture(Location),S)). # with "S" any state

PRECONDITIONS: # pact of the action in a state S requires its PRECOND list.
pact(take_picture(Location),S):- holds(have_battery, S), 
                                 holds(at(Location), S),
                                 holds(have_camera, S).
                                
FRAME AXIOM:
holds(V, do(take_picture(Location),S)):- holds(V,S), V\=have_battery. # with V a general property. V must be different from what is in "take_picture" delete list; in this case "have_battery".

###################################################
