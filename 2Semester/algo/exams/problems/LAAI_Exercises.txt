-----------------------------
Legend:

> := TM start symbol
_ := TM blank symbol
R := TM "to the right"
L := TM "to the left"
S := TM "stay"
x € X := x belongs to X
_x_ := binary encoding of x

((( ... ))) := dubbio legato all'esame
[[[ ... ]]] := curiosità
------------------------------



##################
#   EXERCISE 1   #
##################

Build a DTM which decides the following language: 

	L = {w € {0,1}* | w contains 01 as a substring}

Study the complexity of the DTM.

SOL:

I can build a 2 tapes DTM which has as alphabet {0,1,>, _}, Q = {q_init, q0, q1, q_halt}, and transition function defined as follows:

		(q_init, >, >) ---> (q0, >, >, R, R)
		(q0, 0, _) ---> (q1, 0, _, R, S)
		(q0, 1, _) ---> (q0, 1, _, R, S)
		(q0, _, _) ---> (q_halt, _, 0, S, S)
		(q1, 1, _) ---> (q_halt, 1, 1, S, S)
		(q1, 0, _) ---> (q1, 0, _, R, S)
		(q1, _, _) ---> (q_halt, _, 0, S, S)


This DTM works in polynomial time (O(n), where n = |w|), because in the worst scenario it has to scan the whole input tape once.



##################
#   EXERCISE 2   #
##################

Prove with a TM or an algorithm that f is in FP class, with f as the scalar product between two lists of rational numbers.


SOL:

In order to perform the scalar we need two vectors of the same size, therefore I suppose that the two input lists have the same size m (siple comparison that can be done in polytime).
To prove that f is in FP I define an algorithm which computes f and works in polynomial time.

	INPUT: L1, L2
	OUTPUT: prod, which is the dot product between L1 and L2

	i = 0
	m = len(L1)
	prod = 0

	while (i < n) do :

		prod = prod + L1[i] * L2[i]
		++i

	return prod

We can easily encode the rational number as binary strings in polynomial time and the lists L1 and L2 can be encoded in polynomial time by using an additional symbol # (as we've seen in class). Both the sum and the product above-mentioned have to be performed among rational numbers, but these operations can be reduced to a sequence of integer sum and multiplication. (((Può bastare o devo essere più esplicita?)))
The number of instructions are O(n), so it is polynomially bounded in the input size n = _(L1,L2)_.
All the instructions can be simulated in polynomial time by TMs:
		- assignment O(1)
		- comparison O(n)
		- sum O(n)
		- product O(n^2) 
		- increment O(n)
		- return O(1)
The intermediate results are the counter i and the product variable prod. Both of them grow polynomially with the input size:
		- i has maximum value n-i
		- prod is the result of the sum on i from 1 to m of L1[i] * L2[i].



##################
#   EXERCISE 3   #
##################

Prove that the following problem is in NP by giving a NTM or by providing certificates and certifiers.

	given a natural number n and a set of natural numbers D, check whether n is the product of distinct elements of D.


SOL:

I prove that the problem is in NP by defining the corresponding language and by finding a polynomially bounded certificate and a certifier which deduces the language in polynomial time.

	 L = { (n,D) | exist p1,...,pm € D . (n = p1 * ... * pm)}
	   |
	   = { (n,D) | exist p1,...pm . M(n,D,p1,...,pm) = 1} 

	   where M is a DTM which outputs 1 if (n,D,p1,...,pm) satisfy the above conditions, and we suppose n, D and p1,...,pm encoded as binary strings.



CERTIFICATES: p1,...,pm which belong to D, in the worst scenario {p1,...,pm} = D, so they are polynomially bounded in length.
CERTIFIER: M, a TM that has to:
				1) check whether p1,...,pm belong to D
				2) check whether p1,...,pm are all different
				3) compute the product of p1,...,pm
				4) compare n with the above-mentioned product

			About the time complexity we can say that:
				1) and 2) can be done in polynomial time, since they are a finite sequence of comparisons 
				3) is a finite sequence of product, so it can be done in polynomial time
				4) is a simple comparison O(|n|)

			=> M works in polynomial time.

Therefore, we can conclude that the problem is in NP.



##################
#   EXERCISE 4   #
##################

Let's consider 1SAT problem, to which class does it belong? 
Prove your claim.


SOL:

SAT1 belongs to P, and I'll prove it by defining an algorithm which decides SAT1 language in polynomial time.

	SAT1 = {_F_ | F is a satisfiable 1CNF}

A 1CNF is simply a conjunction of literals, therefore to check its satisfiability we only need to check whether there is a negative literal in it.
We can number every literals in F and then encode them as binary strings, as well as the negation symbol and the conjunction. This operation can be done in polynomial time, since F is a finite conjunction of literals.

The algorithms which solves SAT1 starts by building the list of positive literals of F (Lp) and the list of negative literals of F (Ln). Then it simply scans Lp and
		- it outputs 0 as soon as an element of Lp is in Ln
		- otherwise it outputs 1
Therefore, the algorithm mainly performs comparison operations, which can be simulated in polynomial time by a TM. The number of these comparisons is of the order of the number of literals in F, so it is polynomially bounded. 
The intermediate results are:
		- Lp and Ln which are polynomially bounded in size, since they have at most a number of elements equal to the number of literals in F;
		- the counters, which are of course polynomially bounded in size (in the worst case they take a value equal to the number of literals in F) and whose increment can be simulated in polynomial time by a TM.

Therefore, the algorithm which deduces SAT1 works in polynomial time.



##################
#   EXERCISE 5   #
##################

Let's consider THREECLIQUE problem, to which class does it belong? 
Prove your claim.

(((
	Per prima cosa, ho risolto l'esercizio supponendo che THREECLIQUE fosse in NP (SOL 1), poi però mi sono accorta che poteva essere anche in P (SOL 2). Siccome sappiamo che P è sottoinsieme di NP, posso ritenere corretta anche la mia prima soluzione?
)))

[[[
	P sottoinsieme di NP sottoinsieme di EXP, dunque THREECLIQUE è anche in EXP, come avrei potuto dimostrarlo?
]]]
	

SOL 1:

THREECLIQUE is a subset of CLIQUE and can be defined as the problem of finding those graph with at least a clique of size exactly 3.
I claim that THREECLIQUE is in NP and I'll prove it by finding a polynomially bounded certificate and a polynomially working certifier.

	THREECLIQUE = { G | G has a clique of size 3}
				|
				= { (V,E) | exist v1, v2, v3 € V .(vi,vj) € E for each i != j € {1,2,3} }
				|
				= { (V,E) | exist v1, v2, v3 . M(V,E,v1,v2,v3) = 1}


CERTIFICATES = v1, v2, v3 which are polynomially bounded in size, since they belong to V.
CERTIFIER = the DTM M, which
				- outputs 1 if v1,v2,v3 € V and (vi,vj) € E for each i != j € {1,2,3}
				- outputs 0 otherwise.
			M works in polynomial time since:
					- its input (V,E) can be easily encoded as binary strings in polynomial time
					- the number of instructions is at most |V|, so its polynomially bounded by the input
					- the instructions can be simulated in polynomial time by a TM:
							- comparison O(n)
							- increment O(n)
					- the intermediate results are the counters i = 1,2,3 and j = 1, ..., |V|, so they are polynomially bounded in length.

Therefore THREECLIQUE is in NP.

SOL 2:

THREECLIQUE is in P, since we can define an algorithm which solves the problem in polynomial time.

In THREECLIQUE the number of elements defining the clique is fixed (k = 3) and it's not part of the input, therefore to solve the problem we can simply check all the possible subgraphs of 3 vertexes:
		- the input is a graph G = (V,E), that can be easily encoded as binary strings in polynomial time;
		- if our input graph G has n nodes, we'll have at most n^3 subgraphs to check
		- each subgraph has to be check in order to establish whether it is a clique or not. To do so, we check whether the 3^2 edges of the subgraph are in E, so we'll have at most 3^2 comparisons to perform for each subgraph.
			=> number of instructions polynomially bounded O(n^3 * 3^2) = O(n^3)

		- the operations can be simulated in polynomial time by TMs, since they are only comparisons and increments
		- the intermediate results (the counters and the subgraph) are polynomially bounded in lenght

Therefore our algorithm solves the problem in polynomial time => THREECLIQUE is in P.



##################
#   EXERCISE 6   #
##################

Let's consider ONEINDSET problem, which is a subset of INDSET whose elements are pairs (G,k) such that G is an undirected graph such that each node is contained in at least one edge, and k is a natural number. To which class does ONEINDSET belong? 
Prove your claim.

SOL:

ONEINDSET differs from INDSET only on its edges set E: since each node is contained in at least one edge this means that E has at least |V| elements and that there can be at most |V| - 1 independent nodes. If we define E as a matrix A such that Aij = 1 iff (vi, vj) € E, we know for sure that in each column and in each row of A there will be at least a 1. 
There are no other differences between ONEINDSET and INDSET, therefore we can define the same certificate of polynomial length (the independent set itself) and the same certifier which works in polynomial time:

	-the certifier M takes in input (G,k,W) and checks whether W has size at least k, and whether it is an independent set by simply scanning the matrix A of fixed size |V|x|V|. Therefore, M has to perform a polynomially bounded number of operations that can be simulated in polynomial time by a TM. The intermediate results are the counters and the set W which are polynomially bounded in length.

=> ONEINDSET is in NP.


##################
#   EXERCISE 7   #
##################

Build a DTM which decides the following language: 

	L = {w € {0,1}* | if w contains 01 as a substring, then 01 is followed by 0s}

Study the complexity of the DTM.

SOL:

I build a 2-tapes deterministic turing machine M, with alphabet {0,1, >,_}, Q = {q_init, q0, q1, q2, q_halt} and transition function defined as follows:

				
				(q_init, >, >) ---> (q0, >, >, R, R)
				(q0, 0, _) ---> (q1, 0, _, R, S)
				(q1, 1, _) ---> (q2, 1, _, R, S)
				(q2, 1, _) ---> (q_halt, 1, 0, S, S) # 01 followed by a 1
				(q2, 0, _) ---> (q2, 0, _, R, S)
				(q2, _, _) ---> (q_halt, _, 1, S, S) # 01 followed by 0s (and/or blank symbols)
				(q0, 1, _) ---> (q0, 1, _, R, S)
				(q0, _, _) ---> (q_halt, _, 0, S, S) # Empty string
				(q1, 0, _) ---> (q1, 0, _, R, S)
				(q1, _, _) ---> (q_halt, _, _, S, S) # No 01 in w

Therefore, I supposed that my DTM outputs 1 even if 01 is followed by nothing.

M works in polynomial time, since in the worst case it has to scan once the input string w (and so the input tape).



##################
#   EXERCISE 8   #
##################

Prove with a TM or an algorithm that f is in FP class, with f is such that given two strings v and w, checks whether v  is a substring of w, namely whther w contains an exact occurrence of v.


SOL:

I'll prove that f is in FP by defining an algorithm computes f and works in polynomial time.

	INPUT: w,v
	OUTPUT: 1 if v is in w, 0 otherwise

	n = len(w)
	m = len(v)
	//I suppose that m < n

	i = 0
	j = 0

	while (i < n - m) do

		if v[0] == w[i] then

			while (j < m)

				if v[j] != v[i + j] then

					return 0
				
				++j

			return 1

		 ++i

	return 0


The input of our algorithm are already binary strings.
The number of instructions is polynomially bounded by the string size (|w| = n and |v| = n) and all the instructions can be simulated in polynomial time by a TM:
		- comparison -> linear complexity
		- increment -> linear compleity
		- return -> constant complecity 
		- sum -> linear complexity
The intermediate results are the counters i and j which are polynomially bounded in length (i can be at most n-m-1 and j can be at most m).